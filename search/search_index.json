{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tabby The Cat Plugin Framework Tabby attempts to make developing plugins a breeze in a way where you'll never need to worry about if you're doing something wrong, we handle the heavy baggage for you. Note These docs were written a bit speedily, feel free to make pull requests if you think something should be fixed.","title":"Introduction"},{"location":"#tabby","text":"The Cat Plugin Framework Tabby attempts to make developing plugins a breeze in a way where you'll never need to worry about if you're doing something wrong, we handle the heavy baggage for you. Note These docs were written a bit speedily, feel free to make pull requests if you think something should be fixed.","title":"Tabby"},{"location":"GettingStarted/","text":"Getting Started Before going through the docs its good to learn how to set up your project so that you can develop Tabby plugins as these docs intend. To begin with setting up the project, you'll need to know how to develop the plugin based on where you are. These docs should translate regardless of environment, but the setup process is different between the two Rojo Projects Roblox Studio Before everything else, set up a Rojo project intended for Plugin development Download the tabby.rbxm binary directly from releases and drag it into your src folder named Framework Finally, add a folder named Runtime to your src folder, and you have successfully set up Tabby To build a plugin under Rojo, use the following command: # This is PowerShell syntax, change $env:localappdata to %LOCALAPPDATA% if using the classic command line on Windows rojo build - -output $env:localappdata / Roblox / Plugins / YourPluginName . rbxm Create a Plugin with a new folder, and drag the tabby.rbxm model from Releases into it, then add a second folder named Runtime Enable PluginDebuggingService Plugin Development is a lot easier under Roblox Studio with this enabled. You can do this by navigating to Studio Settings and searching for Enable Plugin Debugging Service . Studio will need to restart before enabling this. To build plugins under Roblox Studio, you can simply right click the top folder and click Save as Local Plugin... Tip You can name the Framework module whatever you want, however, make sure to change code examples to reflect this change Code not working as intended? Rojo Project Roblox Studio Make sure the structure of the project is as followed src Runtime Framework default.project.json Your plugin should have a folder and a module script with this structure PluginRoot Runtime Framework","title":"Installation"},{"location":"GettingStarted/#getting-started","text":"Before going through the docs its good to learn how to set up your project so that you can develop Tabby plugins as these docs intend. To begin with setting up the project, you'll need to know how to develop the plugin based on where you are. These docs should translate regardless of environment, but the setup process is different between the two Rojo Projects Roblox Studio Before everything else, set up a Rojo project intended for Plugin development Download the tabby.rbxm binary directly from releases and drag it into your src folder named Framework Finally, add a folder named Runtime to your src folder, and you have successfully set up Tabby To build a plugin under Rojo, use the following command: # This is PowerShell syntax, change $env:localappdata to %LOCALAPPDATA% if using the classic command line on Windows rojo build - -output $env:localappdata / Roblox / Plugins / YourPluginName . rbxm Create a Plugin with a new folder, and drag the tabby.rbxm model from Releases into it, then add a second folder named Runtime Enable PluginDebuggingService Plugin Development is a lot easier under Roblox Studio with this enabled. You can do this by navigating to Studio Settings and searching for Enable Plugin Debugging Service . Studio will need to restart before enabling this. To build plugins under Roblox Studio, you can simply right click the top folder and click Save as Local Plugin... Tip You can name the Framework module whatever you want, however, make sure to change code examples to reflect this change Code not working as intended? Rojo Project Roblox Studio Make sure the structure of the project is as followed src Runtime Framework default.project.json Your plugin should have a folder and a module script with this structure PluginRoot Runtime Framework","title":"Getting Started"},{"location":"reference/","text":"API Reference This page refers to all features currently available in Tabby Reference Map init.lua exports Types.lua type exports -- Exports Tabby . Action = require ( Exports . Action ) Tabby . Create = require ( Exports . Create ) Tabby . Event = require ( Exports . Event ) Tabby . Form = require ( Exports . Form ) Tabby . Input = require ( Exports . Input ) Tabby . Plugin = Plugin Tabby . QtInterface = require ( script . QtInterface ) Tabby . RuntimeScript = require ( script . Internal . Runtime ). newScript -- Types export type Action < A ..., R ... > = Types . Action < A ..., R ... > export type Component < RenderParams , Inst > = Types . Component < RenderParams , Inst > export type Event < A ... > = Types . Event < A ... > export type Form < O ..., C ... > = Types . Form < O ..., C ... > export type QtAction = Types . QtAction export type QtMenu = Types . QtMenu export type QtToolbar = Types . QtToolbar export type RuntimeScript = Types . RuntimeScript export type TabbyInputObject = Types . TabbyInputObject --@internal/Common export type TypedRBXScriptSignal < T ... > = { Connect : ( TypedRBXScriptSignal < T ... > , func : ( T ...) -> ()) -> RBXScriptConnection , ConnectParallel : ( TypedRBXScriptSignal < T ... > , func : ( T ...) -> ()) -> RBXScriptConnection , Once : ( TypedRBXScriptSignal < T ... > , func : ( T ...) -> ()) -> RBXScriptConnection , Wait : ( TypedRBXScriptSignal < T ... > ) -> T ..., } --@exports/Action.lua export type Action < I ..., O ... > = { _signal : ( I ...) -> O ..., Name : string , ShowWarnings : boolean , await : ( Action < I ..., O ... > , I ...) -> ( boolean , O ...), handleAsync : ( Action < I ..., O ... > , func : ( boolean , O ...) -> (), I ...) -> () } --@exports/Create.lua export type Component < RenderParams , Inst > = { ClassName : string , _templateInst : Inst ? , story : (( params : RenderParams ) -> Inst ) ? , render : (( params : RenderParams ) -> Inst ) ? , GetTemplate : ( Component < RenderParams , Inst > , () -> Inst ) -> Inst , GetCallback : ( Component < RenderParams , Inst > ) -> ( useStoryMode : boolean ? ) -> ( params : RenderParams ) -> Inst } --@exports/Event.lua export type Event < A ... > = { Connect : ( Event < A ... > , func : ( A ...) -> ()) -> () -> (), ConnectedFunctions : {( A ...) -> ()}, Wait : ( Event < A ... > ) -> A ..., WaitingThreads : { thread }, Fire : ( Event < A ... > , A ...) -> () } --@exports/Form.lua export type Form < O ..., C ... > = { Name : string , DockWidget : any , IsLoaded : boolean , Open : ( Form < O ..., C ... > , O ...) -> (), Close : ( Form < O ..., C ... > , C ...) -> (), Loading : ( Form < O ..., C ... > ) -> () ? , Opening : ( Form < O ..., C ... > , O ...) -> () ? , Closing : ( Form < O ..., C ... > , C ...) -> () ? , [ string ]: any } --@exports/Input.lua export type TabbyInputObject = { KeyCode : Enum . KeyCode , Position : Vector2 , UserInputType : Enum . UserInputType , UserInputState : Enum . UserInputState } --@QtInterface export type QtInterface < T , M > = { ID : string , Type : T , Mount : M ? , GetMount : ( QtInterface < T , M > ) -> M , IsA : ( QtInterface < T , M > , typeName : string ) -> boolean } type ButtonConfig = { ID : string , Name : string , Description : string , Icon : string ? , ClickableWhenViewportHidden : boolean ? , Callback : ( button : PluginToolbarButton , toolbar : QtToolbar ) -> () ? } export type QtMenu = QtInterface < \"PluginMenu\" , PluginMenu > & { initialise : ( QtMenu , title : string ? , icon : string ? ) -> QtMenu , Clear : ( QtMenu ) -> (), ShowAsync : ( QtMenu ) -> (), AddMenu : ( QtMenu , menu : QtMenu ) -> QtMenu , AddAction : ( QtMenu , action : QtAction ) -> QtMenu , AddNewAction : ( QtMenu , id : string , title : string ? , icon : string ? , callback : () -> () ? ) -> QtMenu , Children : { QtAction | QtMenu }, ChildActions : {[ string ]: QtAction }, ChildMenus : {[ string ]: QtMenu }, GetFullTree : ( QtMenu ) -> { QtAction | QtMenu }, SetActionIcon : ( QtMenu , iconID : string ) -> (), SetIcon : ( QtMenu , iconID : string ) -> () } export type QtAction = QtInterface < \"PluginAction\" , PluginAction > & { initialise : ( QtAction , name : string ? , description : string ? , icon : string ? , allowBinding : boolean ? , callback : () -> () ? ) -> QtAction , IsTemporaryAction : boolean , SetIcon : ( QtAction , iconID : string ) -> never } export type QtToolbar = QtInterface < \"PluginToolbar\" , PluginToolbar > & { initialise : ( QtToolbar ) -> QtToolbar , AddButton : ( QtToolbar , buttonConfig : ButtonConfig ) -> QtToolbar , SetIcon : ( QtToolbar , buttonID : string , iconID : string ? ) -> (), Buttons : { [ string ]: PluginToolbarButton } } --@Internal/RuntimeScript export type RuntimeScript = { Name : string , Priority : number , Source : string , Init : () -> () ? , Activated : () -> () ? , Deactivated : () -> () ? , Unloading : () -> () ? }","title":"Summary"},{"location":"reference/#api-reference","text":"This page refers to all features currently available in Tabby Reference Map init.lua exports Types.lua type exports -- Exports Tabby . Action = require ( Exports . Action ) Tabby . Create = require ( Exports . Create ) Tabby . Event = require ( Exports . Event ) Tabby . Form = require ( Exports . Form ) Tabby . Input = require ( Exports . Input ) Tabby . Plugin = Plugin Tabby . QtInterface = require ( script . QtInterface ) Tabby . RuntimeScript = require ( script . Internal . Runtime ). newScript -- Types export type Action < A ..., R ... > = Types . Action < A ..., R ... > export type Component < RenderParams , Inst > = Types . Component < RenderParams , Inst > export type Event < A ... > = Types . Event < A ... > export type Form < O ..., C ... > = Types . Form < O ..., C ... > export type QtAction = Types . QtAction export type QtMenu = Types . QtMenu export type QtToolbar = Types . QtToolbar export type RuntimeScript = Types . RuntimeScript export type TabbyInputObject = Types . TabbyInputObject --@internal/Common export type TypedRBXScriptSignal < T ... > = { Connect : ( TypedRBXScriptSignal < T ... > , func : ( T ...) -> ()) -> RBXScriptConnection , ConnectParallel : ( TypedRBXScriptSignal < T ... > , func : ( T ...) -> ()) -> RBXScriptConnection , Once : ( TypedRBXScriptSignal < T ... > , func : ( T ...) -> ()) -> RBXScriptConnection , Wait : ( TypedRBXScriptSignal < T ... > ) -> T ..., } --@exports/Action.lua export type Action < I ..., O ... > = { _signal : ( I ...) -> O ..., Name : string , ShowWarnings : boolean , await : ( Action < I ..., O ... > , I ...) -> ( boolean , O ...), handleAsync : ( Action < I ..., O ... > , func : ( boolean , O ...) -> (), I ...) -> () } --@exports/Create.lua export type Component < RenderParams , Inst > = { ClassName : string , _templateInst : Inst ? , story : (( params : RenderParams ) -> Inst ) ? , render : (( params : RenderParams ) -> Inst ) ? , GetTemplate : ( Component < RenderParams , Inst > , () -> Inst ) -> Inst , GetCallback : ( Component < RenderParams , Inst > ) -> ( useStoryMode : boolean ? ) -> ( params : RenderParams ) -> Inst } --@exports/Event.lua export type Event < A ... > = { Connect : ( Event < A ... > , func : ( A ...) -> ()) -> () -> (), ConnectedFunctions : {( A ...) -> ()}, Wait : ( Event < A ... > ) -> A ..., WaitingThreads : { thread }, Fire : ( Event < A ... > , A ...) -> () } --@exports/Form.lua export type Form < O ..., C ... > = { Name : string , DockWidget : any , IsLoaded : boolean , Open : ( Form < O ..., C ... > , O ...) -> (), Close : ( Form < O ..., C ... > , C ...) -> (), Loading : ( Form < O ..., C ... > ) -> () ? , Opening : ( Form < O ..., C ... > , O ...) -> () ? , Closing : ( Form < O ..., C ... > , C ...) -> () ? , [ string ]: any } --@exports/Input.lua export type TabbyInputObject = { KeyCode : Enum . KeyCode , Position : Vector2 , UserInputType : Enum . UserInputType , UserInputState : Enum . UserInputState } --@QtInterface export type QtInterface < T , M > = { ID : string , Type : T , Mount : M ? , GetMount : ( QtInterface < T , M > ) -> M , IsA : ( QtInterface < T , M > , typeName : string ) -> boolean } type ButtonConfig = { ID : string , Name : string , Description : string , Icon : string ? , ClickableWhenViewportHidden : boolean ? , Callback : ( button : PluginToolbarButton , toolbar : QtToolbar ) -> () ? } export type QtMenu = QtInterface < \"PluginMenu\" , PluginMenu > & { initialise : ( QtMenu , title : string ? , icon : string ? ) -> QtMenu , Clear : ( QtMenu ) -> (), ShowAsync : ( QtMenu ) -> (), AddMenu : ( QtMenu , menu : QtMenu ) -> QtMenu , AddAction : ( QtMenu , action : QtAction ) -> QtMenu , AddNewAction : ( QtMenu , id : string , title : string ? , icon : string ? , callback : () -> () ? ) -> QtMenu , Children : { QtAction | QtMenu }, ChildActions : {[ string ]: QtAction }, ChildMenus : {[ string ]: QtMenu }, GetFullTree : ( QtMenu ) -> { QtAction | QtMenu }, SetActionIcon : ( QtMenu , iconID : string ) -> (), SetIcon : ( QtMenu , iconID : string ) -> () } export type QtAction = QtInterface < \"PluginAction\" , PluginAction > & { initialise : ( QtAction , name : string ? , description : string ? , icon : string ? , allowBinding : boolean ? , callback : () -> () ? ) -> QtAction , IsTemporaryAction : boolean , SetIcon : ( QtAction , iconID : string ) -> never } export type QtToolbar = QtInterface < \"PluginToolbar\" , PluginToolbar > & { initialise : ( QtToolbar ) -> QtToolbar , AddButton : ( QtToolbar , buttonConfig : ButtonConfig ) -> QtToolbar , SetIcon : ( QtToolbar , buttonID : string , iconID : string ? ) -> (), Buttons : { [ string ]: PluginToolbarButton } } --@Internal/RuntimeScript export type RuntimeScript = { Name : string , Priority : number , Source : string , Init : () -> () ? , Activated : () -> () ? , Deactivated : () -> () ? , Unloading : () -> () ? }","title":"API Reference"},{"location":"reference/Action/","text":"Action Actions provide a way to create asynchronous execution that can be either awaited upon or handled asynchronously Action<I..., O...>(actionName: string, callback: (I...) -> R...) -> Action<I..., O...> Creates a new Action object function await ( Action < I ..., O ... > , I ...) -> ( boolean , O ...) Yields the running thread calls the action with I... , returns if it worked, and either the return params as O... , or an error as string . function handleAsync ( Action < I ..., O ... > , func : ( boolean , O ...) -> (), I ...) -> () Runs the action asynchronously and returns the result to func . This function works similary to await except it's response is sent to a callback asynchronously. string Name Refers to the name of the Action defined in the constructor boolean ShowWarnings Controls if errors from await are warned into the console, default = false Members not safe to write to These members are casted directly onto the object. They are safe to read, but not to write to _signal: (I...) -> O...","title":"Action"},{"location":"reference/Action/#action","text":"Actions provide a way to create asynchronous execution that can be either awaited upon or handled asynchronously Action<I..., O...>(actionName: string, callback: (I...) -> R...) -> Action<I..., O...> Creates a new Action object","title":"Action"},{"location":"reference/Action/#function-await","text":"( Action < I ..., O ... > , I ...) -> ( boolean , O ...) Yields the running thread calls the action with I... , returns if it worked, and either the return params as O... , or an error as string .","title":"function await"},{"location":"reference/Action/#function-handleasync","text":"( Action < I ..., O ... > , func : ( boolean , O ...) -> (), I ...) -> () Runs the action asynchronously and returns the result to func . This function works similary to await except it's response is sent to a callback asynchronously.","title":"function handleAsync"},{"location":"reference/Action/#string-name","text":"Refers to the name of the Action defined in the constructor","title":"string Name"},{"location":"reference/Action/#boolean-showwarnings","text":"Controls if errors from await are warned into the console, default = false Members not safe to write to These members are casted directly onto the object. They are safe to read, but not to write to _signal: (I...) -> O...","title":"boolean ShowWarnings"},{"location":"reference/Event/","text":"Event Event works almost identically to RBXScriptSignal objects except with a few changes to make them easier to work with. This object needs to be explicitly casted for typechecking to work on it properly, ie: local MeowEvent: Event<string> = Event() Event<A...>(): Event<A...> function Connect ( Event < A ... > , func : ( A ...) -> ()) -> () Creates a callback that is fired when the event is signalled. function Fire ( Event < A ... > , A ...) -> () Signals all connected callbacks then releases waiting threads Warning Do not rely on implementation details. function Wait ( Event < A ... > ) -> A ... Yields the current thread until the event is fired elsewhere Members not safe to write to These members are casted directly onto the object. They are safe to read, but not to write to ConnectedFunctions: {(A...) -> ()} WaitingThreads: {thread}","title":"Event"},{"location":"reference/Event/#event","text":"Event works almost identically to RBXScriptSignal objects except with a few changes to make them easier to work with. This object needs to be explicitly casted for typechecking to work on it properly, ie: local MeowEvent: Event<string> = Event() Event<A...>(): Event<A...>","title":"Event"},{"location":"reference/Event/#function-connect","text":"( Event < A ... > , func : ( A ...) -> ()) -> () Creates a callback that is fired when the event is signalled.","title":"function Connect"},{"location":"reference/Event/#function-fire","text":"( Event < A ... > , A ...) -> () Signals all connected callbacks then releases waiting threads Warning Do not rely on implementation details.","title":"function Fire"},{"location":"reference/Event/#function-wait","text":"( Event < A ... > ) -> A ... Yields the current thread until the event is fired elsewhere Members not safe to write to These members are casted directly onto the object. They are safe to read, but not to write to ConnectedFunctions: {(A...) -> ()} WaitingThreads: {thread}","title":"function Wait"},{"location":"reference/Form/","text":"WIP - Refer to type export if possible","title":"Form"},{"location":"reference/Form/#wip-refer-to-type-export-if-possible","text":"","title":"WIP - Refer to type export if possible"},{"location":"reference/Input/","text":"WIP - Refer to type export if possible","title":"Input"},{"location":"reference/Input/#wip-refer-to-type-export-if-possible","text":"","title":"WIP - Refer to type export if possible"},{"location":"reference/RuntimeScript/","text":"RuntimeScript RuntimeScript is the main entry point for Tabby when working with the framework. Why is my RuntimeScript not running? There can be a few reasons why your script isn't running, but here are a few common causes with simple fixes, since all warnings are prefixed with Module did not load because , the messages have been truncated a bit it did not return a RuntimeScript Priority is not a positive integer above 0 it cannot yield! Module did not return exactly one value Ensure you're returning a RuntimeScript + return HelloWorldScript Use priorites above 0 or dont use Priority at all, and only assign numbers to Priority - HelloWorldScript.Priority = -1 - HelloWorldScript.Priority = \"5\" --actually a type error + HelloWorldScript.Priority = 5 Its common for Plugins to yield when their script starts, however Tabby needs RuntimeScripts to return within the same tick. Write your yields instead in the Init block HelloWorldScript.Init = function() - print(meow) + print(yieldingMeow:await()) end - meow = yieldingMeow:await() See it did not return a RuntimeScript (string) -> RuntimeScript Returns a new RuntimeScript RuntimeScripts are singletons You may only have have one RuntimeScript assigned to any ID string Name The unique name of this RuntimeScript number Priority The execution priority of this RuntimeScript object. Note This must be a positive integer above 0, it will error otherwise and not load your script string Source [DEPRECATED] A leftover property from an older prototype build of Tabby that is no longer maintained, this will always equal Runtime . Lifecycle Hooks RuntimeScript exposes Lifecycle hooks intended to invoke functions when certain events happen in the outer world of Studio. All lifecycle hooks have the type of () -> () . function Activated Invoked when the plugin is activated through Input:Activate RuntimeScript . Activated = function () -- Do something with the mouse maybe? end function Deactivated Invoked when the plugin is deactivated through Input:Deactivate or another plugin taking activation control RuntimeScript . Deactivated = function () -- Stop doing that something with the mouse? end function Init Invoked when the plugin has done loading all Runtime scripts RuntimeScript . Init = function () print ( \"Meow!\" ) end function Unloading Invoked when the plugin is unloading RuntimeScript . Unloading = function () CoreGui . YourVeryCoolPluginGui : Destroy () end","title":"RuntimeScript"},{"location":"reference/RuntimeScript/#runtimescript","text":"RuntimeScript is the main entry point for Tabby when working with the framework. Why is my RuntimeScript not running? There can be a few reasons why your script isn't running, but here are a few common causes with simple fixes, since all warnings are prefixed with Module did not load because , the messages have been truncated a bit it did not return a RuntimeScript Priority is not a positive integer above 0 it cannot yield! Module did not return exactly one value Ensure you're returning a RuntimeScript + return HelloWorldScript Use priorites above 0 or dont use Priority at all, and only assign numbers to Priority - HelloWorldScript.Priority = -1 - HelloWorldScript.Priority = \"5\" --actually a type error + HelloWorldScript.Priority = 5 Its common for Plugins to yield when their script starts, however Tabby needs RuntimeScripts to return within the same tick. Write your yields instead in the Init block HelloWorldScript.Init = function() - print(meow) + print(yieldingMeow:await()) end - meow = yieldingMeow:await() See it did not return a RuntimeScript (string) -> RuntimeScript Returns a new RuntimeScript RuntimeScripts are singletons You may only have have one RuntimeScript assigned to any ID","title":"RuntimeScript"},{"location":"reference/RuntimeScript/#string-name","text":"The unique name of this RuntimeScript","title":"string Name"},{"location":"reference/RuntimeScript/#number-priority","text":"The execution priority of this RuntimeScript object. Note This must be a positive integer above 0, it will error otherwise and not load your script","title":"number Priority"},{"location":"reference/RuntimeScript/#string-source","text":"[DEPRECATED] A leftover property from an older prototype build of Tabby that is no longer maintained, this will always equal Runtime .","title":"string Source"},{"location":"reference/RuntimeScript/#lifecycle-hooks","text":"RuntimeScript exposes Lifecycle hooks intended to invoke functions when certain events happen in the outer world of Studio. All lifecycle hooks have the type of () -> () .","title":"Lifecycle Hooks"},{"location":"reference/RuntimeScript/#function-activated","text":"Invoked when the plugin is activated through Input:Activate RuntimeScript . Activated = function () -- Do something with the mouse maybe? end","title":"function Activated"},{"location":"reference/RuntimeScript/#function-deactivated","text":"Invoked when the plugin is deactivated through Input:Deactivate or another plugin taking activation control RuntimeScript . Deactivated = function () -- Stop doing that something with the mouse? end","title":"function Deactivated"},{"location":"reference/RuntimeScript/#function-init","text":"Invoked when the plugin has done loading all Runtime scripts RuntimeScript . Init = function () print ( \"Meow!\" ) end","title":"function Init"},{"location":"reference/RuntimeScript/#function-unloading","text":"Invoked when the plugin is unloading RuntimeScript . Unloading = function () CoreGui . YourVeryCoolPluginGui : Destroy () end","title":"function Unloading"},{"location":"reference/create/","text":"WIP - Refer to type export if possible","title":"Create Library"},{"location":"reference/create/#wip-refer-to-type-export-if-possible","text":"","title":"WIP - Refer to type export if possible"},{"location":"reference/create/Component/","text":"WIP - Refer to type export if possible","title":"Component"},{"location":"reference/create/Component/#wip-refer-to-type-export-if-possible","text":"","title":"WIP - Refer to type export if possible"},{"location":"reference/qt-interface/","text":"QtInterface QtInterface provides a wrapper for PluginAction , PluginMenu and PluginToolbar function GetAction (QtInterface, actionName: string) -> QtAction Returns a QtAction InterfaceBlob function GetMenu (QtInterface, menuName: string) -> QtMenu Returns a QtMenu InterfaceBlob function GetToolbar (QtInterface, toolbarName: string) -> QtToolbar Returns a QtToolbar InterfaceBlob","title":"QtInterface"},{"location":"reference/qt-interface/#qtinterface","text":"QtInterface provides a wrapper for PluginAction , PluginMenu and PluginToolbar","title":"QtInterface"},{"location":"reference/qt-interface/#function-getaction","text":"(QtInterface, actionName: string) -> QtAction Returns a QtAction InterfaceBlob","title":"function GetAction"},{"location":"reference/qt-interface/#function-getmenu","text":"(QtInterface, menuName: string) -> QtMenu Returns a QtMenu InterfaceBlob","title":"function GetMenu"},{"location":"reference/qt-interface/#function-gettoolbar","text":"(QtInterface, toolbarName: string) -> QtToolbar Returns a QtToolbar InterfaceBlob","title":"function GetToolbar"},{"location":"reference/qt-interface/InterfaceBlob/","text":"InterfaceBlob InterfaceBlob is the superclass for the QtInterface objects. It cannot be created externally. InterfaceBlobs are singletons You can only initialise InterfaceBlobs once, every future initialisation will fail function GetMount (InterfaceBlob) -> Instance? Returns the currently loaded Instance in the Interface (this will be typecasted when used because QtInterface itself is generic) string ID The ID used to initialise this object from one of the QtInterface:Get methods. function IsA (InterfaceBlob, Type: string) -> boolean Matches the type of the blob against the parameter value. string<Literal> Type The literal type of this Interface, when used in an inheritor, has a literal string type Members not safe to write to These members are casted directly onto the object. They are safe to read, but not to write to Mount: any (Use GetMount instead.)","title":"InterfaceBlob"},{"location":"reference/qt-interface/InterfaceBlob/#interfaceblob","text":"InterfaceBlob is the superclass for the QtInterface objects. It cannot be created externally. InterfaceBlobs are singletons You can only initialise InterfaceBlobs once, every future initialisation will fail","title":"InterfaceBlob"},{"location":"reference/qt-interface/InterfaceBlob/#function-getmount","text":"(InterfaceBlob) -> Instance? Returns the currently loaded Instance in the Interface (this will be typecasted when used because QtInterface itself is generic)","title":"function GetMount"},{"location":"reference/qt-interface/InterfaceBlob/#string-id","text":"The ID used to initialise this object from one of the QtInterface:Get methods.","title":"string ID"},{"location":"reference/qt-interface/InterfaceBlob/#function-isa","text":"(InterfaceBlob, Type: string) -> boolean Matches the type of the blob against the parameter value.","title":"function IsA"},{"location":"reference/qt-interface/InterfaceBlob/#stringliteral-type","text":"The literal type of this Interface, when used in an inheritor, has a literal string type Members not safe to write to These members are casted directly onto the object. They are safe to read, but not to write to Mount: any (Use GetMount instead.)","title":"string&lt;Literal&gt; Type"},{"location":"reference/qt-interface/QtAction/","text":"QtAction inherits InterfaceBlob with generic types \"PluginAction\" and PluginAction Acts as a wrapper for the PluginAction object. function initialise (QtAction, name: string?, description: string?, icon: string?, allowBinding: boolean?, callback: () -> ()?) -> QtAction Initialises the QtAction by creating a PluginAction boolean IsTemporaryAction If this action was created through a QtMenu . Warning Do not store temporary QtActions in the few places where they're exposed, only interface with it from iterating over QtMenu.ChildActions / QtMenu.Children function SetIcon Unimplemented This is unimplemented, do not use it. It exists hoping Roblox gives a way to change PluginAction icons.","title":"QtAction"},{"location":"reference/qt-interface/QtAction/#qtaction","text":"inherits InterfaceBlob with generic types \"PluginAction\" and PluginAction Acts as a wrapper for the PluginAction object.","title":"QtAction"},{"location":"reference/qt-interface/QtAction/#function-initialise","text":"(QtAction, name: string?, description: string?, icon: string?, allowBinding: boolean?, callback: () -> ()?) -> QtAction Initialises the QtAction by creating a PluginAction","title":"function initialise"},{"location":"reference/qt-interface/QtAction/#boolean-istemporaryaction","text":"If this action was created through a QtMenu . Warning Do not store temporary QtActions in the few places where they're exposed, only interface with it from iterating over QtMenu.ChildActions / QtMenu.Children","title":"boolean IsTemporaryAction"},{"location":"reference/qt-interface/QtAction/#function-seticon","text":"Unimplemented This is unimplemented, do not use it. It exists hoping Roblox gives a way to change PluginAction icons.","title":"function SetIcon"},{"location":"reference/qt-interface/QtMenu/","text":"QtMenu inherits InterfaceBlob with generic types \"PluginMenu\" and PluginMenu This acts as a wrapper for the PluginMenu object. This is a very developed and complex wrapper. function AddAction (QtMenu, action: QtAction) -> QtMenu Adds a pre-existing QtAction to the menu. function AddNewAction (QtMenu, id: string, title: string?, icon: string?, callback: () -> ()?) -> QtMenu Creates a temporary action and assigns it to the menu. Warning Do not store temporary QtActions in the few places where they're exposed, only interface with it from iterating over QtMenu.ChildActions / QtMenu.Children function AddMenu (QtMenu, menu: QtMenu) -> QtMenu Adds a sub-menu to the menu Danger This should be obvious, but no, you cannot add a menu as a sub-menu of itself. Please stop trying this, im serious table ChildActions {[string]: QtAction} A table indexed by Action ID of QtActions in the menu table ChildMenus {[string]: QtMenu} A table indexed by Menu ID of sub QtMenus in the menu table Children {QtAction|QtMenu} An ordered list of QtActions and QtMenus in the list, this is in the order of how it's displayed function Clear (QtMenu) -> () Clears the menu of all actions and sub-menus, and deletes temporary actions. function GetFullTree (QtMenu) -> {QtAction|QtMenu} Returns all members of the menu and submenus. The order is undefined. function initialise (QtMenu, title: string?, icon: string?) -> QtMenu Initialises the menu. function SetActionIcon Unimplemented This is unimplemented, do not use it. It exists hoping Roblox gives a way to change PluginAction icons. function SetIcon (QtAction, iconID: string) -> () Changes the Menu icon function ShowAsync (QtAction) -> () Shows the menu","title":"QtMenu"},{"location":"reference/qt-interface/QtMenu/#qtmenu","text":"inherits InterfaceBlob with generic types \"PluginMenu\" and PluginMenu This acts as a wrapper for the PluginMenu object. This is a very developed and complex wrapper.","title":"QtMenu"},{"location":"reference/qt-interface/QtMenu/#function-addaction","text":"(QtMenu, action: QtAction) -> QtMenu Adds a pre-existing QtAction to the menu.","title":"function AddAction"},{"location":"reference/qt-interface/QtMenu/#function-addnewaction","text":"(QtMenu, id: string, title: string?, icon: string?, callback: () -> ()?) -> QtMenu Creates a temporary action and assigns it to the menu. Warning Do not store temporary QtActions in the few places where they're exposed, only interface with it from iterating over QtMenu.ChildActions / QtMenu.Children","title":"function AddNewAction"},{"location":"reference/qt-interface/QtMenu/#function-addmenu","text":"(QtMenu, menu: QtMenu) -> QtMenu Adds a sub-menu to the menu Danger This should be obvious, but no, you cannot add a menu as a sub-menu of itself. Please stop trying this, im serious","title":"function AddMenu"},{"location":"reference/qt-interface/QtMenu/#table-childactions","text":"{[string]: QtAction} A table indexed by Action ID of QtActions in the menu","title":"table ChildActions"},{"location":"reference/qt-interface/QtMenu/#table-childmenus","text":"{[string]: QtMenu} A table indexed by Menu ID of sub QtMenus in the menu","title":"table ChildMenus"},{"location":"reference/qt-interface/QtMenu/#table-children","text":"{QtAction|QtMenu} An ordered list of QtActions and QtMenus in the list, this is in the order of how it's displayed","title":"table Children"},{"location":"reference/qt-interface/QtMenu/#function-clear","text":"(QtMenu) -> () Clears the menu of all actions and sub-menus, and deletes temporary actions.","title":"function Clear"},{"location":"reference/qt-interface/QtMenu/#function-getfulltree","text":"(QtMenu) -> {QtAction|QtMenu} Returns all members of the menu and submenus. The order is undefined.","title":"function GetFullTree"},{"location":"reference/qt-interface/QtMenu/#function-initialise","text":"(QtMenu, title: string?, icon: string?) -> QtMenu Initialises the menu.","title":"function initialise"},{"location":"reference/qt-interface/QtMenu/#function-setactionicon","text":"Unimplemented This is unimplemented, do not use it. It exists hoping Roblox gives a way to change PluginAction icons.","title":"function SetActionIcon"},{"location":"reference/qt-interface/QtMenu/#function-seticon","text":"(QtAction, iconID: string) -> () Changes the Menu icon","title":"function SetIcon"},{"location":"reference/qt-interface/QtMenu/#function-showasync","text":"(QtAction) -> () Shows the menu","title":"function ShowAsync"},{"location":"reference/qt-interface/QtToolbar/","text":"QtToolbar inherits InterfaceBlob with generic types \"PluginToolbar\" and PluginToolbar function AddButton (QtToolbar, buttonConfig: ButtonConfig) -> QtToolbar Adds a button to the toolbar. This can be chained as such: initialise():AddButton():AddButton()... Button Config Type type ButtonConfig = { ID: string, Name: string, Description: string, Icon: string?, ClickableWhenViewportHidden: boolean?, Callback: (button: PluginToolbarButton, toolbar: QtToolbar) -> ()? } table Buttons {[string]: PluginToolbarButton} A table of buttons indexed by their IDs function initialise (QtToolbar) -> QtToolbar Initialises the toolbar. function SetIcon (QtToolbar, buttonID: string, iconID: string?) -> () Changes a button icon, matching it against it's ID.","title":"QtToolbar"},{"location":"reference/qt-interface/QtToolbar/#qttoolbar","text":"inherits InterfaceBlob with generic types \"PluginToolbar\" and PluginToolbar","title":"QtToolbar"},{"location":"reference/qt-interface/QtToolbar/#function-addbutton","text":"(QtToolbar, buttonConfig: ButtonConfig) -> QtToolbar Adds a button to the toolbar. This can be chained as such: initialise():AddButton():AddButton()... Button Config Type type ButtonConfig = { ID: string, Name: string, Description: string, Icon: string?, ClickableWhenViewportHidden: boolean?, Callback: (button: PluginToolbarButton, toolbar: QtToolbar) -> ()? }","title":"function AddButton"},{"location":"reference/qt-interface/QtToolbar/#table-buttons","text":"{[string]: PluginToolbarButton} A table of buttons indexed by their IDs","title":"table Buttons"},{"location":"reference/qt-interface/QtToolbar/#function-initialise","text":"(QtToolbar) -> QtToolbar Initialises the toolbar.","title":"function initialise"},{"location":"reference/qt-interface/QtToolbar/#function-seticon","text":"(QtToolbar, buttonID: string, iconID: string?) -> () Changes a button icon, matching it against it's ID.","title":"function SetIcon"}]}